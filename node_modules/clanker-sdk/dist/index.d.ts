export { C as ClankerTokenV3 } from './clankerTokenV3-BqHTF9QY.js';
import { a as Chain, C as ClankerTokenV4, b as ClankerDeployment } from './deploy-BvFgwMVl.js';
export { d as CLANKERS, g as Chains, h as ClankerDeployments, f as Clankers, D as DeployTokenOptions, R as RelatedV3_1, c as RelatedV4, T as Type, i as clankerConfigFor } from './deploy-BvFgwMVl.js';
import { ContractConstructorArgs, Hex, PublicClient } from 'viem';
import { C as ClankerToken_v3_1_abi, a as ClankerToken_v4_abi } from './ClankerToken-Dra5lppJ.js';
import { StandardMerkleTree } from '@openzeppelin/merkle-tree';
import 'zod/v4';

declare const DEGEN_ADDRESS: `0x${string}`;
declare const NATIVE_ADDRESS: `0x${string}`;
declare const CLANKER_ADDRESS: `0x${string}`;
declare const ANON_ADDRESS: `0x${string}`;
declare const HIGHER_ADDRESS: `0x${string}`;
declare const CB_BTC_ADDRESS: `0x${string}`;
declare const A0X_ADDRESS: `0x${string}`;
declare const WETH_ADDRESSES: Record<Chain, `0x${string}`>;
declare const DEFAULT_SUPPLY = 100000000000000000000000000000n;
declare enum PoolPositions {
    Standard = "Standard",
    Project = "Project",
    TwentyETH = "TwentyETH"
}
type PoolPosition = {
    tickLower: number;
    tickUpper: number;
    positionBps: number;
};
declare const POOL_POSITIONS: Record<PoolPositions, PoolPosition[]>;
declare enum FeeConfigs {
    DynamicBasic = "DynamicBasic",
    StaticBasic = "StaticBasic",
    Dynamic3 = "Dynamic3"
}
declare const FEE_CONFIGS: Record<FeeConfigs, Required<ClankerTokenV4['fees']>>;

declare const findVanityAddress: (args: ContractConstructorArgs<typeof ClankerToken_v3_1_abi>, admin: `0x${string}`, suffix?: `0x${string}`, options?: {
    chainId?: number;
}) => Promise<{
    salt: `0x${string}`;
    token: `0x${string}`;
}>;
declare const findVanityAddressV4: (args: ContractConstructorArgs<typeof ClankerToken_v4_abi>, admin: `0x${string}`, suffix: `0x${string}` | undefined, config: ClankerDeployment) => Promise<{
    salt: `0x${string}`;
    token: `0x${string}`;
}>;
/**
 * Predict the token address for a V4 deployment with a custom salt using CREATE2.
 *
 * The Clanker contract uses: keccak256(abi.encode(tokenAdmin, salt))
 * as the actual CREATE2 salt.
 *
 * @param args Constructor arguments for the token
 * @param config Clanker deployment configuration
 * @param salt Custom salt for CREATE2 deployment
 * @param tokenAdmin Token admin address (used to derive the actual CREATE2 salt)
 * @returns The predicted token address
 */
declare const predictTokenAddressV4: (args: ContractConstructorArgs<typeof ClankerToken_v4_abi>, config: ClankerDeployment, salt: Hex, tokenAdmin: `0x${string}`) => `0x${string}`;

/**
 * Calculate starting tick and spacing for a token pooled against ETH.
 *
 * @param marketCap Target market cap for the token
 * @returns Tick information for the pool
 */
declare const getTickFromMarketCap: (marketCap: number) => {
    pairedToken: "WETH";
    tickIfToken0IsClanker: number;
    tickSpacing: number;
};
/**
 * Calculate the tick for a desired market cap in USDC
 *
 * @param marketCapUSDC - Desired market cap in USDC (e.g., 10 for $10)
 * @param tickSpacing - Tick spacing (must be multiple of this, default 200)
 * @returns The tick value rounded to the nearest tickSpacing
 *
 * Formula:
 * - Total supply: 100B tokens (10^11 * 10^18 with decimals = 10^29)
 * - USDC: 6 decimals (10^6)
 * - Price per token = (marketCap * 10^6) / 10^29 = marketCap / 10^23
 * - tick = log(price) / log(1.0001)
 */
declare function getTickFromMarketCapUSDC(marketCapUSDC: number, tickSpacing?: number): number;

interface AirdropEntry {
    account: `0x${string}`;
    amount: number;
}
declare function createMerkleTree(entries: AirdropEntry[]): {
    tree: StandardMerkleTree<[string, string]>;
    root: `0x${string}`;
    entries: [string, string][];
};
declare function getMerkleProof(tree: StandardMerkleTree<[string, string]>, entries: [string, string][], account: `0x${string}`, amount: number): `0x${string}`[];
declare function encodeAirdropData(merkleRoot: `0x${string}`, lockupDuration: number, vestingDuration: number): `0x${string}`;

/**
 * Represents an allowlist entry with an address and allowed ETH amount
 */
interface AllowlistEntry {
    /** The wallet address that is allowed to participate */
    address: `0x${string}`;
    /** The maximum amount of ETH this address is allowed to contribute (in ETH, not wei) */
    allowedAmount: number;
}
/**
 * Allowlist proof structure for contract calls
 */
interface AllowlistProof {
    /** The maximum amount of ETH the buyer is allowed to contribute */
    allowedAmount: bigint;
    /** Merkle proof bytes32 array */
    proof: `0x${string}`[];
}
/**
 * Create a Merkle tree from allowlist entries
 *
 * @param entries Array of allowlist entries with addresses and allowed amounts
 * @returns Object containing the Merkle tree, root, and formatted entries
 *
 * @example
 * ```typescript
 * const entries = [
 *   { address: '0x123...', allowedAmount: 1.0 }, // 1 ETH max
 *   { address: '0x456...', allowedAmount: 0.5 }, // 0.5 ETH max
 * ];
 * const { root, tree } = createAllowlistMerkleTree(entries);
 * ```
 */
declare function createAllowlistMerkleTree(entries: AllowlistEntry[]): {
    tree: StandardMerkleTree<[string, string]>;
    root: `0x${string}`;
    entries: [string, string][];
};
/**
 * Get a Merkle proof for a specific address in the allowlist
 *
 * @param tree The Merkle tree created from allowlist entries
 * @param entries The formatted entries array from createAllowlistMerkleTree
 * @param address The address to get a proof for
 * @param allowedAmount The allowed amount for this address (in ETH)
 * @returns Array of proof hashes
 *
 * @example
 * ```typescript
 * const { tree, entries } = createAllowlistMerkleTree(allowlistEntries);
 * const proof = getAllowlistMerkleProof(tree, entries, '0x123...', 1.0);
 * ```
 */
declare function getAllowlistMerkleProof(tree: StandardMerkleTree<[string, string]>, entries: [string, string][], address: `0x${string}`, allowedAmount: number): `0x${string}`[];
/**
 * Encode allowlist initialization data for starting a presale with a merkle root
 *
 * @param merkleRoot The merkle root for the allowlist
 * @returns Encoded bytes for the allowlistInitializationData parameter
 *
 * @example
 * ```typescript
 * const { root } = createAllowlistMerkleTree(entries);
 * const initData = encodeAllowlistInitializationData(root);
 * // Use initData in presaleConfig.allowlistInitializationData
 * ```
 */
declare function encodeAllowlistInitializationData(merkleRoot: `0x${string}`): `0x${string}`;
/**
 * Encode allowlist proof data for buying into a presale with proof
 *
 * @param allowedAmount The maximum allowed ETH amount for the buyer (in ETH)
 * @param proof The merkle proof array
 * @returns Encoded bytes for the proof parameter
 *
 * @example
 * ```typescript
 * const proof = getAllowlistMerkleProof(tree, entries, buyerAddress, 1.0);
 * const proofData = encodeAllowlistProofData(1.0, proof);
 * // Use proofData when calling buyIntoPresaleWithProof
 * ```
 */
declare function encodeAllowlistProofData(allowedAmount: number, proof: `0x${string}`[]): `0x${string}`;
/**
 * Get the allowlist contract address for a specific chain
 *
 * @param chainId The chain ID
 * @returns The allowlist contract address, or undefined if not available on this chain
 */
declare function getAllowlistAddress(chainId: Chain): `0x${string}` | undefined;
/**
 * Get allowlist information for a presale
 *
 * @param publicClient The viem public client
 * @param presaleId The presale ID
 * @param chainId The chain ID
 * @returns Allowlist data including presale owner, merkle root, and enabled status
 */
declare function getAllowlistInfo(publicClient: PublicClient, presaleId: bigint, chainId: Chain): Promise<{
    presaleOwner: `0x${string}`;
    merkleRoot: `0x${string}`;
    enabled: boolean;
}>;
/**
 * Get the allowed amount for a specific buyer in a presale
 *
 * @param publicClient The viem public client
 * @param presaleId The presale ID
 * @param buyer The buyer's address
 * @param proof The encoded proof data (use encodeAllowlistProofData or pass '0x' for no proof)
 * @param chainId The chain ID
 * @returns The allowed amount in wei (returns max uint256 if allowlist is disabled)
 */
declare function getAllowedAmountForBuyer(publicClient: PublicClient, presaleId: bigint, buyer: `0x${string}`, proof: `0x${string}`, chainId: Chain): Promise<bigint>;
/**
 * Helper to verify if a buyer is allowed to purchase a specific amount
 *
 * @param publicClient The viem public client
 * @param presaleId The presale ID
 * @param buyer The buyer's address
 * @param desiredAmount The amount the buyer wants to purchase (in ETH)
 * @param proof The encoded proof data
 * @param chainId The chain ID
 * @returns Object with isAllowed boolean and allowedAmount in ETH
 */
declare function verifyBuyerAllowance(publicClient: PublicClient, presaleId: bigint, buyer: `0x${string}`, desiredAmount: number, proof: `0x${string}`, chainId: Chain): Promise<{
    isAllowed: boolean;
    allowedAmountEth: number;
    allowedAmountWei: bigint;
}>;

export { A0X_ADDRESS, ANON_ADDRESS, type AirdropEntry, type AllowlistEntry, type AllowlistProof, CB_BTC_ADDRESS, CLANKER_ADDRESS, Chain, ClankerDeployment, ClankerTokenV4, DEFAULT_SUPPLY, DEGEN_ADDRESS, FEE_CONFIGS, FeeConfigs, HIGHER_ADDRESS, NATIVE_ADDRESS, POOL_POSITIONS, PoolPositions, WETH_ADDRESSES, createAllowlistMerkleTree, createMerkleTree, encodeAirdropData, encodeAllowlistInitializationData, encodeAllowlistProofData, findVanityAddress, findVanityAddressV4, getAllowedAmountForBuyer, getAllowlistAddress, getAllowlistInfo, getAllowlistMerkleProof, getMerkleProof, getTickFromMarketCap, getTickFromMarketCapUSDC, predictTokenAddressV4, verifyBuyerAllowance };
