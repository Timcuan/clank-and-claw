import { C as ClankerTransactionConfig, f as ClankerAirdrop_v4_abi, c as ClankerResult, g as Clanker_PresaleEthToCreator_v4_1_abi, h as Clanker_PresaleAllowlist_v4_1_abi } from '../../write-clanker-contracts-wZSL1UyM.js';
import { MerkleTree } from '@openzeppelin/merkle-tree/dist/merkletree.js';
import * as z from 'zod/v4';
import { a as Chain, C as ClankerTokenV4 } from '../../deploy-BvFgwMVl.js';
import { Clanker } from '../index.js';
import { C as ClankerError } from '../../errors-5Gv28Tkr.js';
import 'viem';
import '../../ClankerToken-Dra5lppJ.js';

declare const AirdropEntrySchema: z.ZodArray<z.ZodObject<{
    account: z.ZodCustom<`0x${string}`, `0x${string}`>;
    amount: z.ZodNumber;
}, z.core.$strip>>;
type AirdropRecipient = z.input<typeof AirdropEntrySchema>[0];
type MerkleEntry = [account: `0x${string}`, amount: string];
/**
 * Create an airdrop for the recipients.
 *
 * @param recipients Recipients recieving airdrop.
 * @param options.tokenDecimals Custom token decimals.
 * @returns Tree to save offline and Airdrop data for the smart contract.
 */
declare function createAirdrop(recipients: AirdropRecipient[], options?: {
    tokenDecimals: bigint;
}): {
    tree: MerkleTree<MerkleEntry>;
    airdrop: {
        merkleRoot: `0x${string}`;
        amount: number;
    };
};
/**
 * Register an airdrop merkle tree with the Clanker service.
 *
 * @dev Requires that the associated token is already deployed and indexed. The token
 * must also have the merkle root associated with it.
 *
 * @param token The token associated with the tree.
 * @param tree The tree to register.
 * @returns Success.
 */
declare function registerAirdrop(token: `0x${string}`, tree: MerkleTree<MerkleEntry>): Promise<boolean>;
/**
 * Get all proofs for an account given a merkle tree.
 *
 * @param tree The tree to check.
 * @param account The account to check for.
 * @returns All proofs and their associated entries for claiming.
 */
declare function getAirdropProofs(tree: MerkleTree<MerkleEntry>, account: `0x${string}`): {
    proofs: {
        proof: `0x${string}`[];
        entry: {
            account: `0x${string}`;
            amount: bigint;
        };
    }[];
};
/**
 * Get all proofs for an account given a token that has a merkle tree associated with it. The token and tree must have been registered with the Clanker service.
 *
 * @param token The token with the airdrop.
 * @param account The account to check for.
 * @returns All proofs and their associated entries for claiming.
 */
declare function fetchAirdropProofs(token: `0x${string}`, account: `0x${string}`): Promise<{
    proofs: {
        proof: `0x${string}`[];
        entry: {
            account: `0x${string}`;
            amount: bigint;
        };
    }[];
}>;
/**
 * Create a transaction to claim a specific airdrop for.
 *
 * @param token The token that did the airdrop
 * @param recipient The address recieving the airdrop
 * @param amount The amount registered in the airdrop. Note, this must be the exact registered amount.
 * @param proof Merkle proof for the address and amount (see `getProofs`)
 * @returns Arguments that can be used with a viem transaction.
 */
declare function getClaimAirdropTransaction({ token, recipient, amount, proof, chainId, }: {
    chainId: Chain;
    token: `0x${string}`;
    recipient: `0x${string}`;
    amount: bigint;
    proof: `0x${string}`[];
}): ClankerTransactionConfig<typeof ClankerAirdrop_v4_abi, 'claim'>;
/**
 * Claim an airdrop
 *
 * @param clanker Clanker object used for claiming
 * @param token The token that did the airdrop
 * @param recipient The address recieving the airdrop
 * @param amount The amount registered in the airdrop. Note, this must be the exact registered amount.
 * @param proof Merkle proof for the address and amount (see `getProofs`)
 * @returns Outcome of the transaction
 */
declare function claimAirdrop(data: {
    clanker: Clanker;
    token: `0x${string}`;
    recipient: `0x${string}`;
    amount: bigint;
    proof: `0x${string}`[];
}): ClankerResult<{
    txHash: `0x${string}`;
}>;

declare enum PresaleStatus {
    NotCreated = 0,
    Active = 1,
    SuccessfulMinimumHit = 2,
    SuccessfulMaximumHit = 3,
    Failed = 4,
    Claimable = 5
}
declare const PresaleConfigSchema: z.ZodObject<{
    minEthGoal: z.ZodNumber;
    maxEthGoal: z.ZodNumber;
    presaleDuration: z.ZodNumber;
    recipient: z.ZodCustom<`0x${string}`, `0x${string}`>;
    lockupDuration: z.ZodDefault<z.ZodNumber>;
    vestingDuration: z.ZodDefault<z.ZodNumber>;
    allowlist: z.ZodDefault<z.ZodCustom<`0x${string}`, `0x${string}`>>;
    allowlistInitializationData: z.ZodDefault<z.ZodCustom<`0x${string}`, `0x${string}`>>;
    presaleSupplyBps: z.ZodDefault<z.ZodNumber>;
}, z.core.$strip>;
type PresaleConfig = z.input<typeof PresaleConfigSchema>;
/**
 * Get a transaction to start a presale
 *
 * @param deploymentConfig The deployment configuration for the token
 * @param presaleConfig The presale configuration
 * @param chainId The chain ID
 * @returns Transaction configuration for starting a presale
 */
declare function getStartPresaleTransaction({ tokenConfig, presaleConfig, }: {
    tokenConfig: ClankerTokenV4;
    presaleConfig: PresaleConfig;
}): Promise<ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'startPresale'>>;
/**
 * Start a presale
 *
 * @param clanker Clanker object used for starting presale
 * @param deploymentConfig The deployment configuration for the token
 * @param presaleConfig The presale configuration
 * @returns Outcome of the transaction
 */
declare function startPresale(data: {
    clanker: Clanker;
    tokenConfig: ClankerTokenV4;
    presaleConfig: PresaleConfig;
}): Promise<({
    txHash: `0x${string}`;
} & {
    error?: undefined;
}) | ({
    txHash?: undefined;
} & {
    error: ClankerError;
})>;
/**
 * Get a transaction to buy into a presale
 *
 * @param presaleId The ID of the presale
 * @param chainId The chain ID
 * @param value The ETH amount to send (in wei)
 * @returns Transaction configuration for buying into a presale
 */
declare function getBuyIntoPresaleTransaction({ presaleId, chainId, value, }: {
    presaleId: bigint;
    chainId: Chain;
    value: bigint;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'buyIntoPresale'>;
/**
 * Buy into a presale
 *
 * @param clanker Clanker object used for buying into presale
 * @param presaleId The ID of the presale
 * @param ethAmount The ETH amount to send (in ETH, will be converted to wei)
 * @returns Outcome of the transaction
 */
declare function buyIntoPresale(data: {
    clanker: Clanker;
    presaleId: bigint;
    ethAmount: number;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get a transaction to end a presale
 *
 * A presale can be ended in three scenarios:
 * 1. Maximum ETH goal is reached (anyone can call)
 * 2. Minimum ETH goal is reached AND duration has expired (anyone can call)
 * 3. Minimum ETH goal is reached AND presale owner wants to end early (only presale owner can call)
 *
 * @param presaleId The ID of the presale
 * @param salt The salt for token deployment
 * @param chainId The chain ID
 * @returns Transaction configuration for ending a presale
 */
declare function getEndPresaleTransaction({ presaleId, salt, chainId, }: {
    presaleId: bigint;
    salt: `0x${string}`;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'endPresale'>;
/**
 * End a presale and deploy the token
 *
 * A presale can be ended in three scenarios:
 * 1. Maximum ETH goal is reached (anyone can call)
 * 2. Minimum ETH goal is reached AND duration has expired (anyone can call)
 * 3. Minimum ETH goal is reached AND presale owner wants to end early (only presale owner can call)
 *
 * If the presale is successful (minimum goal reached), this will:
 * - Deploy the token
 * - Send raised ETH to the recipient (minus Clanker fee)
 * - Allow users to claim tokens after lockup period
 *
 * @param clanker Clanker object used for ending presale
 * @param presaleId The ID of the presale
 * @param salt The salt for token deployment
 * @returns Outcome of the transaction
 */
declare function endPresale(data: {
    clanker: Clanker;
    presaleId: bigint;
    salt: `0x${string}`;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get a transaction to claim tokens from a presale
 *
 * @param presaleId The ID of the presale
 * @param chainId The chain ID
 * @returns Transaction configuration for claiming tokens
 */
declare function getClaimTokensTransaction({ presaleId, chainId, }: {
    presaleId: bigint;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'claimTokens'>;
/**
 * Claim tokens from a presale
 *
 * @param clanker Clanker object used for claiming tokens
 * @param presaleId The ID of the presale
 * @returns Outcome of the transaction
 */
declare function claimTokens(data: {
    clanker: Clanker;
    presaleId: bigint;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get a transaction to claim ETH from a successful presale (for presale owners)
 *
 * This function allows the presale owner to claim the raised ETH after the presale
 * has been completed and the token has been deployed. Only callable by the presale
 * owner or contract owner. A Clanker fee is deducted and the remaining ETH is sent
 * to the recipient.
 *
 * @param presaleId The ID of the presale
 * @param recipient The recipient address for the ETH (must be presale owner if called by contract owner)
 * @param chainId The chain ID
 * @returns Transaction configuration for claiming ETH
 */
declare function getClaimEthTransaction({ presaleId, recipient, chainId, }: {
    presaleId: bigint;
    recipient: `0x${string}`;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'claimEth'>;
/**
 * Claim ETH from a successful presale
 *
 * This function allows the presale owner to claim the raised ETH after the presale
 * has been completed and the token has been deployed. Only callable by the presale
 * owner or contract owner. A Clanker fee is deducted and the remaining ETH is sent
 * to the recipient. Can only be called once per presale.
 *
 * Note: For withdrawing from failed or active presales, use `withdrawFromPresale` instead.
 *
 * @param clanker Clanker object used for claiming ETH
 * @param presaleId The ID of the presale
 * @param recipient The recipient address for the ETH (must be presale owner if called by contract owner)
 * @returns Outcome of the transaction
 */
declare function claimEth(data: {
    clanker: Clanker;
    presaleId: bigint;
    recipient: `0x${string}`;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get presale information
 *
 * @param clanker Clanker object used for reading presale data
 * @param presaleId The ID of the presale
 * @returns Presale data
 */
declare function getPresale(data: {
    clanker: Clanker;
    presaleId: bigint;
}): Promise<{
    status: number;
    deploymentConfig: {
        tokenConfig: {
            tokenAdmin: `0x${string}`;
            name: string;
            symbol: string;
            salt: `0x${string}`;
            image: string;
            metadata: string;
            context: string;
            originatingChainId: bigint;
        };
        poolConfig: {
            hook: `0x${string}`;
            pairedToken: `0x${string}`;
            tickIfToken0IsClanker: number;
            tickSpacing: number;
            poolData: `0x${string}`;
        };
        lockerConfig: {
            locker: `0x${string}`;
            rewardAdmins: readonly `0x${string}`[];
            rewardRecipients: readonly `0x${string}`[];
            rewardBps: readonly number[];
            tickLower: readonly number[];
            tickUpper: readonly number[];
            positionBps: readonly number[];
            lockerData: `0x${string}`;
        };
        mevModuleConfig: {
            mevModule: `0x${string}`;
            mevModuleData: `0x${string}`;
        };
        extensionConfigs: readonly {
            extension: `0x${string}`;
            msgValue: bigint;
            extensionBps: number;
            extensionData: `0x${string}`;
        }[];
    };
    allowlist: `0x${string}`;
    presaleOwner: `0x${string}`;
    minEthGoal: bigint;
    maxEthGoal: bigint;
    endTime: bigint;
    deployedToken: `0x${string}`;
    ethRaised: bigint;
    tokenSupply: bigint;
    deploymentExpected: boolean;
    ethClaimed: boolean;
    lockupDuration: bigint;
    vestingDuration: bigint;
    lockupEndTime: bigint;
    vestingEndTime: bigint;
    clankerFee: bigint;
}>;
/**
 * Get presale state (same as getPresale but different function name in contract)
 *
 * @param clanker Clanker object used for reading presale state
 * @param presaleId The ID of the presale
 * @returns Presale data
 */
declare function getPresaleState(data: {
    clanker: Clanker;
    presaleId: bigint;
}): Promise<readonly [number, {
    tokenConfig: {
        tokenAdmin: `0x${string}`;
        name: string;
        symbol: string;
        salt: `0x${string}`;
        image: string;
        metadata: string;
        context: string;
        originatingChainId: bigint;
    };
    poolConfig: {
        hook: `0x${string}`;
        pairedToken: `0x${string}`;
        tickIfToken0IsClanker: number;
        tickSpacing: number;
        poolData: `0x${string}`;
    };
    lockerConfig: {
        locker: `0x${string}`;
        rewardAdmins: readonly `0x${string}`[];
        rewardRecipients: readonly `0x${string}`[];
        rewardBps: readonly number[];
        tickLower: readonly number[];
        tickUpper: readonly number[];
        positionBps: readonly number[];
        lockerData: `0x${string}`;
    };
    mevModuleConfig: {
        mevModule: `0x${string}`;
        mevModuleData: `0x${string}`;
    };
    extensionConfigs: readonly {
        extension: `0x${string}`;
        msgValue: bigint;
        extensionBps: number;
        extensionData: `0x${string}`;
    }[];
}, `0x${string}`, `0x${string}`, bigint, bigint, bigint, `0x${string}`, bigint, bigint, boolean, boolean, bigint, bigint, bigint, bigint, bigint]>;
/**
 * Get the amount of ETH a user has contributed to a presale
 *
 * @param clanker Clanker object used for reading presale data
 * @param presaleId The ID of the presale
 * @param user The user address
 * @returns Amount of ETH contributed
 */
declare function getPresaleBuys(data: {
    clanker: Clanker;
    presaleId: bigint;
    user: `0x${string}`;
}): Promise<bigint>;
/**
 * Get the amount of tokens a user has claimed from a presale
 *
 * @param clanker Clanker object used for reading presale data
 * @param presaleId The ID of the presale
 * @param user The user address
 * @returns Amount of tokens claimed
 */
declare function getPresaleClaimed(data: {
    clanker: Clanker;
    presaleId: bigint;
    user: `0x${string}`;
}): Promise<bigint>;
/**
 * Get the amount available for a user to claim from a presale
 *
 * @param clanker Clanker object used for reading presale data
 * @param presaleId The ID of the presale
 * @param user The user address
 * @returns Amount available to claim
 */
declare function getAmountAvailableToClaim(data: {
    clanker: Clanker;
    presaleId: bigint;
    user: `0x${string}`;
}): Promise<bigint>;
/**
 * Get a transaction to withdraw from a presale
 *
 * @param presaleId The ID of the presale
 * @param amount The amount of ETH to withdraw (in wei)
 * @param recipient The recipient address for the withdrawn ETH
 * @param chainId The chain ID
 * @returns Transaction configuration for withdrawing from a presale
 */
declare function getWithdrawFromPresaleTransaction({ presaleId, amount, recipient, chainId, }: {
    presaleId: bigint;
    amount: bigint;
    recipient: `0x${string}`;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'withdrawFromPresale'>;
/**
 * Withdraw ETH from an active presale
 *
 * @param clanker Clanker object used for withdrawing from presale
 * @param presaleId The ID of the presale
 * @param ethAmount The ETH amount to withdraw (in ETH, will be converted to wei)
 * @param recipient The recipient address for the withdrawn ETH
 * @returns Outcome of the transaction
 */
declare function withdrawFromPresale(data: {
    clanker: Clanker;
    presaleId: bigint;
    ethAmount: number;
    recipient: `0x${string}`;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get the allowlist contract address for a specific chain
 *
 * @param chainId The chain ID to get the allowlist address for
 * @returns The allowlist contract address, or undefined if not available
 */
declare function getAllowlistAddress(chainId: Chain): `0x${string}` | undefined;
/**
 * Get a transaction to buy into a presale with allowlist proof
 *
 * Use this when buying into a presale that has an allowlist enabled.
 * The proof must contain your allowlist proof data (merkle proof + allowed amount).
 *
 * @param presaleId The ID of the presale
 * @param chainId The chain ID
 * @param value The ETH amount to send (in wei)
 * @param proof The encoded proof data from encodeAllowlistProofData
 * @returns Transaction configuration for buying into a presale with proof
 */
declare function getBuyIntoPresaleWithProofTransaction({ presaleId, chainId, value, proof, }: {
    presaleId: bigint;
    chainId: Chain;
    value: bigint;
    proof: `0x${string}`;
}): ClankerTransactionConfig<typeof Clanker_PresaleEthToCreator_v4_1_abi, 'buyIntoPresaleWithProof'>;
/**
 * Buy into a presale with allowlist proof
 *
 * Use this when buying into a presale that has an allowlist enabled.
 * You must provide proof that your address is on the allowlist.
 *
 * @param clanker Clanker object used for buying into presale
 * @param presaleId The ID of the presale
 * @param ethAmount The ETH amount to send (in ETH, will be converted to wei)
 * @param proof The encoded proof data from encodeAllowlistProofData
 * @returns Outcome of the transaction
 *
 * @example
 * ```typescript
 * import { createAllowlistMerkleTree, getAllowlistMerkleProof, encodeAllowlistProofData } from '../utils/presale-allowlist';
 *
 * // Get your proof from the allowlist
 * const { tree, entries } = createAllowlistMerkleTree(allowlistEntries);
 * const proof = getAllowlistMerkleProof(tree, entries, buyerAddress, 1.0);
 * const proofData = encodeAllowlistProofData(1.0, proof);
 *
 * // Buy with proof
 * await buyIntoPresaleWithProof({ clanker, presaleId: 1n, ethAmount: 0.5, proof: proofData });
 * ```
 */
declare function buyIntoPresaleWithProof(data: {
    clanker: Clanker;
    presaleId: bigint;
    ethAmount: number;
    proof: `0x${string}`;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;

/**
 * Get a transaction to set the merkle root for a presale allowlist
 *
 * Only callable by the presale owner. This allows updating the allowlist
 * after the presale has been created.
 *
 * @param presaleId The presale ID
 * @param merkleRoot The new merkle root
 * @param chainId The chain ID
 * @returns Transaction configuration
 */
declare function getSetMerkleRootTransaction({ presaleId, merkleRoot, chainId, }: {
    presaleId: bigint;
    merkleRoot: `0x${string}`;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleAllowlist_v4_1_abi, 'setMerkleRoot'>;
/**
 * Set the merkle root for a presale allowlist
 *
 * Only callable by the presale owner. This allows updating the allowlist
 * after the presale has been created.
 *
 * @param clanker Clanker object
 * @param presaleId The presale ID
 * @param merkleRoot The new merkle root
 * @returns Outcome of the transaction
 */
declare function setMerkleRoot(data: {
    clanker: Clanker;
    presaleId: bigint;
    merkleRoot: `0x${string}`;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get a transaction to set an address override for a presale allowlist
 *
 * Only callable by the presale owner. Address overrides take precedence
 * over the merkle tree allowlist. Setting allowedAmount to 0 effectively
 * removes the override.
 *
 * @param presaleId The presale ID
 * @param buyer The buyer's address to override
 * @param allowedAmount The allowed amount in wei (0 to remove override)
 * @param chainId The chain ID
 * @returns Transaction configuration
 */
declare function getSetAddressOverrideTransaction({ presaleId, buyer, allowedAmount, chainId, }: {
    presaleId: bigint;
    buyer: `0x${string}`;
    allowedAmount: bigint;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleAllowlist_v4_1_abi, 'setAddressOverride'>;
/**
 * Set an address override for a presale allowlist
 *
 * Only callable by the presale owner. Address overrides take precedence
 * over the merkle tree allowlist. This is useful for manually adding
 * addresses without regenerating the entire merkle tree.
 *
 * @param clanker Clanker object
 * @param presaleId The presale ID
 * @param buyer The buyer's address to override
 * @param allowedAmountEth The allowed amount in ETH (0 to remove override)
 * @returns Outcome of the transaction
 *
 * @example
 * ```typescript
 * // Allow a specific address to buy up to 2 ETH
 * await setAddressOverride({
 *   clanker,
 *   presaleId: 1n,
 *   buyer: '0x123...',
 *   allowedAmountEth: 2.0
 * });
 *
 * // Remove the override (set to 0)
 * await setAddressOverride({
 *   clanker,
 *   presaleId: 1n,
 *   buyer: '0x123...',
 *   allowedAmountEth: 0
 * });
 * ```
 */
declare function setAddressOverride(data: {
    clanker: Clanker;
    presaleId: bigint;
    buyer: `0x${string}`;
    allowedAmountEth: number;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;
/**
 * Get a transaction to enable or disable the allowlist for a presale
 *
 * Only callable by the presale owner. When disabled, anyone can buy
 * into the presale without restrictions. When enabled, buyers must
 * provide proof or have an address override.
 *
 * @param presaleId The presale ID
 * @param enabled Whether to enable or disable the allowlist
 * @param chainId The chain ID
 * @returns Transaction configuration
 */
declare function getSetAllowlistEnabledTransaction({ presaleId, enabled, chainId, }: {
    presaleId: bigint;
    enabled: boolean;
    chainId: Chain;
}): ClankerTransactionConfig<typeof Clanker_PresaleAllowlist_v4_1_abi, 'setAllowlistEnabled'>;
/**
 * Enable or disable the allowlist for a presale
 *
 * Only callable by the presale owner. When disabled, anyone can buy
 * into the presale without restrictions. When enabled, buyers must
 * provide proof or have an address override.
 *
 * @param clanker Clanker object
 * @param presaleId The presale ID
 * @param enabled Whether to enable or disable the allowlist
 * @returns Outcome of the transaction
 *
 * @example
 * ```typescript
 * // Disable the allowlist to let anyone participate
 * await setAllowlistEnabled({ clanker, presaleId: 1n, enabled: false });
 *
 * // Re-enable the allowlist
 * await setAllowlistEnabled({ clanker, presaleId: 1n, enabled: true });
 * ```
 */
declare function setAllowlistEnabled(data: {
    clanker: Clanker;
    presaleId: bigint;
    enabled: boolean;
}): ClankerResult<{
    txHash: `0x${string}`;
}>;

export { type AirdropRecipient, type PresaleConfig, PresaleStatus, buyIntoPresale, buyIntoPresaleWithProof, claimAirdrop, claimEth, claimTokens, createAirdrop, endPresale, fetchAirdropProofs, getAirdropProofs, getAllowlistAddress, getAmountAvailableToClaim, getBuyIntoPresaleTransaction, getBuyIntoPresaleWithProofTransaction, getClaimAirdropTransaction, getClaimEthTransaction, getClaimTokensTransaction, getEndPresaleTransaction, getPresale, getPresaleBuys, getPresaleClaimed, getPresaleState, getSetAddressOverrideTransaction, getSetAllowlistEnabledTransaction, getSetMerkleRootTransaction, getStartPresaleTransaction, getWithdrawFromPresaleTransaction, registerAirdrop, setAddressOverride, setAllowlistEnabled, setMerkleRoot, startPresale, withdrawFromPresale };
